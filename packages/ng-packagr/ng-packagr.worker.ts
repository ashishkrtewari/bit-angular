import { CompilerOptions as TsCompilerOptions } from '@angular/compiler-cli';
import { PACKAGE_JSON } from '@teambit/legacy/dist/constants';
import PackageJsonFile from '@teambit/legacy/dist/consumer/component/package-json-file';
import removeFilesAndEmptyDirsRecursively
  from '@teambit/legacy/dist/utils/fs/remove-files-and-empty-dirs-recursively';
import { expose } from '@teambit/worker';
import { join, posix, resolve } from 'path';
import { NgPackagr } from './ng-packagr.compiler';
import { parse, stringify } from 'flatted';

const ViewEngineTemplateError = "Cannot read property 'type' of null";

export class NgPackagrWorker {
  ngPackagr!: NgPackagr;
  readDefaultTsConfig!: (filename?: string) => any;
  distDir!: string;
  nodeModulesPaths!: string[];

  setup(ngPackagr: string, readDefaultTsConfig: string, distDir = 'dist', nodeModulesPaths: string) {
    this.ngPackagr = require(ngPackagr).ngPackagr();
    this.readDefaultTsConfig = require(readDefaultTsConfig).readDefaultTsConfig;
    this.distDir = distDir;
    this.nodeModulesPaths = parse(nodeModulesPaths);
  }

  async ngPackagrCompilation(
    pathToComponent: string,
    pathToOutputFolder: string,
    tsCompilerOptionsStr: string
  ): Promise<void> {
    const tsCompilerOptions: TsCompilerOptions = parse(tsCompilerOptionsStr);
    const packageJson = PackageJsonFile.loadFromPathSync(pathToOutputFolder, '');

    // update ngPackage entry in package.json for ngPackagr
    packageJson.addOrUpdateProperty('ngPackage', {
      lib: {
        entryFile: join(pathToComponent, 'public-api.ts'),
      },
    });

    // check for dependencies other than tslib and move them to peer dependencies
    // see https://github.com/ng-packagr/ng-packagr/blob/master/docs/dependencies.md#general-recommendation-use-peerdependencies-whenever-possible
    const dependencies = packageJson.packageJsonObject.dependencies;
    const peerDependencies = packageJson.packageJsonObject.peerDependencies;
    const dependenciesKeys = Object.keys(dependencies);
    if(dependenciesKeys.length > 1) {
      dependenciesKeys.forEach((dep: string) => {
        if (dep !== 'tslib') {
          peerDependencies[dep] = dependencies[dep];
          delete dependencies[dep];
        }
      });
      packageJson.addOrUpdateProperty('dependencies', dependencies);
      packageJson.addOrUpdateProperty('peerDependencies', peerDependencies);
    }

    // update package.json
    await packageJson.write();

    // add all node modules paths to TypeScript paths to ensure that it finds all existing dependencies
    tsCompilerOptions.paths = tsCompilerOptions.paths || {};
    tsCompilerOptions.paths["*"] = ["*", ...this.nodeModulesPaths.map(path => join(path, '*'))];

    const parsedTsConfig = this.readDefaultTsConfig();
    parsedTsConfig.options = {...parsedTsConfig.options, ...tsCompilerOptions};

    return this.ngPackagr
      .withTsConfig(parsedTsConfig)
      .forProject(join(pathToOutputFolder, PACKAGE_JSON))
      .build()
      .then(async () => {
        // copy over properties generated by ngPackagr
        const tempPackageJson = (await PackageJsonFile.load(pathToOutputFolder, this.distDir)).packageJsonObject;
        packageJson.mergePackageJsonObject({
          main: posix.join(this.distDir, tempPackageJson.main),
          module: posix.join(this.distDir, tempPackageJson.module),
          es2015: posix.join(this.distDir, tempPackageJson.es2015),
          esm2015: posix.join(this.distDir, tempPackageJson.esm2015),
          fesm2015: posix.join(this.distDir, tempPackageJson.fesm2015),
          typings: posix.join(this.distDir, tempPackageJson.typings),
          metadata: posix.join(this.distDir, tempPackageJson.metadata),
          sideEffects: tempPackageJson.sideEffects === 'true',
          ngPackage: undefined,
        });
        await packageJson.write();
        // delete the package.json file generated by ngPackagr
        await removeFilesAndEmptyDirsRecursively([resolve(join(pathToOutputFolder, 'dist', PACKAGE_JSON))]);
      }, (err: Error) => {
        if(err.message === ViewEngineTemplateError && !tsCompilerOptions.fullTemplateTypeCheck) {
          // eslint-disable-next-line no-console
          console.warn(`\nError "${err.message}" triggered by the Angular compiler, retrying compilation without "fullTemplateTypeCheck" (you should probably create a custom environment using "bit create ng-env my-custom-angular-env" to set this option by default and avoid this error message)\n`);
          return this.ngPackagrCompilation(pathToComponent, pathToOutputFolder, stringify({...tsCompilerOptions, fullTemplateTypeCheck: false}))
        }
        // eslint-disable-next-line no-console
        console.error(err);
      });
  }
}

expose(new NgPackagrWorker());
